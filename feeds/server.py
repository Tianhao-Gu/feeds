import os
import json
import flask
from flask import (
    Flask,
    request
)
from http.client import responses
from flask.logging import default_handler
from .util import epoch_ms
from .config import FeedsConfig
from .auth import (
    validate_service_token,
    validate_user_token,
    validate_user_id,
    validate_user_ids
)
from .exceptions import (
    MissingTokenError,
    InvalidTokenError,
    TokenLookupError
)
import logging

VERSION = "0.0.1"

def _initialize_logging():
    root = logging.getLogger()
    root.addHandler(default_handler)
    root.setLevel('INFO')

def _initialize_config():
    # TODO - include config for:
    # * database access
    return FeedsConfig()

def _log(msg, *args, level=logging.INFO):
    logging.getLogger(__name__).log(level, msg, *args)

def _log_error(error):
    _log("Exception: " + str(error), level=logging.ERROR)

def create_app(test_config=None):
    _initialize_logging()
    _initialize_config()

    app = Flask(__name__, instance_relative_config=True)
    if test_config is None:
        app.config.from_pyfile('config.py', silent=True)
    else:
        app.config.from_mapping(test_config)

    @app.before_request
    def preprocess_request():
        pass

    @app.after_request
    def postprocess_request(response):
        _log('%s %s %s %s', request.method, request.path, response.status_code,
             request.headers.get('User-Agent'))
        return response

    @app.route('/', methods=['GET'])
    def root():
        return flask.jsonify({
            "service": "Notification Feeds Service",
            "version": VERSION,
            "servertime": epoch_ms()
        })

    @app.route('/api/V1/notifications/', methods=['GET'])
    def get_notifications():
        """
        General flow should be:
        1. validate/authenticate user
        2. make user feed object
        3. query user feed for most recent, based on params
        """
        # dummy code below
        max_notes = request.args.get('n', default=10, type=int)
        rev_sort = request.args.get('rev', default=0, type=int)
        rev_sort = False if rev_sort==0 else True
        level_filter = request.args.get('f', default=None, type=str)
        include_seen = request.args.get('seen', default=0, type=int)
        include_seen = False if include_seen==0 else True
        return json.dumps({
            "max_notes": max_notes,
            "rev_sort": rev_sort,
            "level_filter": level_filter,
            "include_seen": include_seen
        })

    @app.route('/api/V1/notification/<note_id>', methods=['GET'])
    def get_single_notification(note_id):
        raise NotImplementedError()

    @app.route('/api/V1/notifications/unsee/', methods=['POST'])
    def mark_notifications_unseen():
        """Form data should have a list of notification ids to mark as unseen"""
        raise NotImplementedError()

    @app.route('/api/V1/notifications/see/', methods=['POST'])
    def mark_notifications_seen():
        """Form data should have a list of notifications to mark as seen"""
        raise NotImplementedError()

    @app.route('/api/V1/notification/', methods=['PUT'])
    def add_notification():
        """
        Adds a new notification for other users to see.
        Form data requires the following:
        * `actor` - a user or org id.
        * `type` - one of the type keywords (see below, TBD (as of 10/8))
        * `target` - optional, a user or org id. - always receives this notification
        * `object` - object of the notice. For invitations, the group to be invited to. For narratives, the narrative UPA.
        * `level` - alert, error, warning, or request.
        * `content` - optional, content of the notification, otherwise it'll be autogenerated from the info above.
        * `global` - true or false. If true, gets added to the global notification feed and everyone gets a copy.

        This also requires a service token as an Authorization header. Once validated, will be used
        as the Source of the notification, and used in logic to determine which feeds get notified.
        """
        token = _get_auth_token(request)
        service = validate_service_token(token)
        return (flask.jsonify({'foo': 'bar'}), 200)

    @app.errorhandler(404)
    def not_found(err):
        return _make_error(err, "Path {} not found.".format(request.path), 404)

    @app.errorhandler(MissingTokenError)
    def handle_missing_token(err):
        _log_error(err)
        return _make_error(err, "Authentication token required", 401)

    @app.errorhandler(InvalidTokenError)
    def handle_invalid_token(err):
        _log_error(err)
        return _make_error(err, "Invalid token", 401)

    @app.errorhandler(TokenLookupError)
    def handle_auth_service_error(err):
        _log_error(err)
        return _make_error(err, "Unable to fetch authentication information", 500)

    def _get_auth_token(request, required=True):
        token = request.headers.get('Authorization')
        if not token and required:
            raise MissingTokenError()
        return token

    def _make_error(error, msg, status_code):
        _log("%s %s", status_code, msg)
        err_response = {
            "http_code": status_code,
            "http_status": responses[status_code],
            "message": msg,
            "time": epoch_ms()
        }
        return (flask.jsonify({'error': err_response}), status_code)
    return app

app = create_app()